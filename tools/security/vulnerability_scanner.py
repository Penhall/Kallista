# tools/security/vulnerability_scanner.py
from typing import Dict, List, Optional
import asyncio
import logging
from datetime import datetime
from pathlib import Path
import re
import json

class VulnerabilityScanner:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.patterns_file = Path("config/security/vulnerability_patterns.json")
        self.patterns = self._load_patterns()

    def _load_patterns(self) -> Dict:
        """Carrega padrões de vulnerabilidade"""
        try:
            if self.patterns_file.exists():
                with open(self.patterns_file) as f:
                    return json.load(f)
            return {
                'code_patterns': self._get_default_code_patterns(),
                'config_patterns': self._get_default_config_patterns(),
                'dependency_patterns': self._get_default_dependency_patterns()
            }
        except Exception as e:
            self.logger.error(f"Failed to load patterns: {str(e)}")
            return {}

    async def scan_project(self, project_path: Path) -> Dict:
        """Realiza scan completo do projeto"""
        try:
            results = {
                'code_vulnerabilities': [],
                'config_vulnerabilities': [],
                'dependency_vulnerabilities': [],
                'timestamp': datetime.utcnow().isoformat()
            }

            # Scan de código
            code_results = await self._scan_code(project_path)
            results['code_vulnerabilities'] = code_results

            # Scan de configurações
            config_results = await self._scan_configs(project_path)
            results['config_vulnerabilities'] = config_results

            # Scan de dependências
            dependency_results = await self._scan_dependencies(project_path)
            results['dependency_vulnerabilities'] = dependency_results

            return results

        except Exception as e:
            self.logger.error(f"Project scan failed: {str(e)}")
            raise

    async def _scan_code(self, project_path: Path) -> List[Dict]:
        """Analisa vulnerabilidades no código"""
        vulnerabilities = []
        
        for pattern in self.patterns['code_patterns']:
            try:
                matches = await self._find_pattern_matches(
                    project_path,
                    pattern['pattern'],
                    pattern.get('file_types', ['*.cs', '*.xaml', '*.config'])
                )
                
                for match in matches:
                    vulnerabilities.append({
                        'type': pattern['type'],
                        'severity': pattern['severity'],
                        'description': pattern['description'],
                        'file': str(match['file']),
                        'line': match['line'],
                        'snippet': match['snippet'],
                        'recommendation': pattern.get('recommendation', '')
                    })
                    
            except Exception as e:
                self.logger.warning(
                    f"Failed to scan for pattern {pattern['type']}: {str(e)}"
                )

        return vulnerabilities

    async def _scan_configs(self, project_path: Path) -> List[Dict]:
        """Analisa vulnerabilidades em arquivos de configuração"""
        vulnerabilities = []
        
        config_files = [
            '*.config',
            '*.json',
            '*.xml',
            '*.settings'
        ]
        
        for pattern in self.patterns['config_patterns']:
            try:
                matches = await self._find_pattern_matches(
                    project_path,
                    pattern['pattern'],
                    config_files
                )
                
                for match in matches:
                    vulnerabilities.append({
                        'type': 'config',
                        'severity': pattern['severity'],
                        'description': pattern['description'],
                        'file': str(match['file']),
                        'line': match['line'],
                        'snippet': match['snippet'],
                        'recommendation': pattern.get('recommendation', '')
                    })
                    
            except Exception as e:
                self.logger.warning(
                    f"Failed to scan config for pattern {pattern['type']}: {str(e)}"
                )

        return vulnerabilities

    async def _scan_dependencies(self, project_path: Path) -> List[Dict]:
        """Analisa vulnerabilidades em dependências"""
        vulnerabilities = []
        
        # Scan packages.config
        packages_config = project_path / 'packages.config'
        if packages_config.exists():
            vulnerabilities.extend(
                await self._scan_packages_config(packages_config)
            )
            
        # Scan .csproj files
        for csproj in project_path.glob('**/*.csproj'):
            vulnerabilities.extend(
                await self._scan_csproj(csproj)
            )
            
        return vulnerabilities

    async def _find_pattern_matches(
        self,
        project_path: Path,
        pattern: str,
        file_types: List[str]
    ) -> List[Dict]:
        """Encontra matches de um padrão em arquivos"""
        matches = []
        
        for file_type in file_types:
            for file_path in project_path.glob(f'**/{file_type}'):
                try:
                    content = file_path.read_text()
                    for i, line in enumerate(content.splitlines(), 1):
                        if re.search(pattern, line):
                            matches.append({
                                'file': file_path,
                                'line': i,
                                'snippet': line.strip()
                            })
                except Exception as e:
                    self.logger.warning(
                        f"Failed to scan file {file_path}: {str(e)}"
                    )

        return matches

    # tools/security/vulnerability_scanner.py (continuação)
    async def _scan_packages_config(self, config_path: Path) -> List[Dict]:
        """Analisa vulnerabilidades em packages.config"""
        vulnerabilities = []
        
        try:
            # Lê arquivo de configuração
            import xml.etree.ElementTree as ET
            tree = ET.parse(config_path)
            root = tree.getroot()
            
            # Analisa cada pacote
            for package in root.findall(".//package"):
                package_id = package.get('id')
                version = package.get('version')
                
                # Verifica vulnerabilidades conhecidas
                vuln_info = await self._check_package_vulnerabilities(
                    package_id,
                    version
                )
                
                if vuln_info:
                    vulnerabilities.append({
                        'type': 'dependency',
                        'severity': vuln_info['severity'],
                        'package': package_id,
                        'version': version,
                        'description': vuln_info['description'],
                        'file': str(config_path),
                        'recommendation': vuln_info.get('recommendation', '')
                    })
                    
        except Exception as e:
            self.logger.error(
                f"Failed to scan packages.config {config_path}: {str(e)}"
            )
            
        return vulnerabilities

    async def _scan_csproj(self, csproj_path: Path) -> List[Dict]:
        """Analisa vulnerabilidades em arquivo .csproj"""
        vulnerabilities = []
        
        try:
            import xml.etree.ElementTree as ET
            tree = ET.parse(csproj_path)
            root = tree.getroot()
            
            # Verifica referências de pacotes
            for ref in root.findall(".//PackageReference"):
                package_id = ref.get('Include')
                version = ref.get('Version')
                
                # Verifica vulnerabilidades conhecidas
                vuln_info = await self._check_package_vulnerabilities(
                    package_id,
                    version
                )
                
                if vuln_info:
                    vulnerabilities.append({
                        'type': 'dependency',
                        'severity': vuln_info['severity'],
                        'package': package_id,
                        'version': version,
                        'description': vuln_info['description'],
                        'file': str(csproj_path),
                        'recommendation': vuln_info.get('recommendation', '')
                    })
                    
        except Exception as e:
            self.logger.error(f"Failed to scan csproj {csproj_path}: {str(e)}")
            
        return vulnerabilities

    async def _check_package_vulnerabilities(
        self,
        package_id: str,
        version: str
    ) -> Optional[Dict]:
        """Verifica vulnerabilidades conhecidas em um pacote"""
        for pattern in self.patterns['dependency_patterns']:
            if (
                pattern['package'] == package_id and
                self._version_matches(version, pattern['version_constraint'])
            ):
                return {
                    'severity': pattern['severity'],
                    'description': pattern['description'],
                    'recommendation': pattern.get('recommendation', '')
                }
        return None

    def _version_matches(self, version: str, constraint: str) -> bool:
        """Verifica se uma versão atende a uma restrição"""
        try:
            import semver
            v = semver.VersionInfo.parse(version)
            
            # Implementa lógica de comparação de versões
            if constraint.startswith('>='):
                min_version = constraint[2:]
                return v >= semver.VersionInfo.parse(min_version)
            elif constraint.startswith('<='):
                max_version = constraint[2:]
                return v <= semver.VersionInfo.parse(max_version)
            elif constraint.startswith('>'):
                min_version = constraint[1:]
                return v > semver.VersionInfo.parse(min_version)
            elif constraint.startswith('<'):
                max_version = constraint[1:]
                return v < semver.VersionInfo.parse(max_version)
            else:
                return v == semver.VersionInfo.parse(constraint)
                
        except Exception:
            return False

    def _get_default_code_patterns(self) -> List[Dict]:
        """Retorna padrões padrão para análise de código"""
        return [
            {
                'type': 'hardcoded_credential',
                'pattern': r'password\s*=\s*["\'].*["\']',
                'severity': 'high',
                'description': 'Hardcoded password found',
                'recommendation': 'Move credentials to secure configuration'
            },
            {
                'type': 'sql_injection',
                'pattern': r'string\.Format.*SELECT.*\+',
                'severity': 'high',
                'description': 'Potential SQL injection vulnerability',
                'recommendation': 'Use parameterized queries'
            },
            {
                'type': 'xss',
                'pattern': r'Response\.Write\(.*\)',
                'severity': 'medium',
                'description': 'Potential XSS vulnerability',
                'recommendation': 'Use proper output encoding'
            },
            {
                'type': 'insecure_crypto',
                'pattern': r'MD5|SHA1',
                'severity': 'medium',
                'description': 'Use of weak cryptographic algorithm',
                'recommendation': 'Use strong hashing algorithms like SHA-256'
            }
        ]

    def _get_default_config_patterns(self) -> List[Dict]:
        """Retorna padrões padrão para análise de configurações"""
        return [
            {
                'type': 'debug_mode',
                'pattern': r'debug\s*=\s*"true"',
                'severity': 'medium',
                'description': 'Debug mode enabled in configuration',
                'recommendation': 'Disable debug mode in production'
            },
            {
                'type': 'clear_text_config',
                'pattern': r'connectionString.*password=\w+',
                'severity': 'high',
                'description': 'Clear text connection string',
                'recommendation': 'Encrypt sensitive configuration data'
            }
        ]

    def _get_default_dependency_patterns(self) -> List[Dict]:
        """Retorna padrões padrão para análise de dependências"""
        return [
            {
                'package': 'Newtonsoft.Json',
                'version_constraint': '<13.0.1',
                'severity': 'high',
                'description': 'Known vulnerabilities in older versions',
                'recommendation': 'Upgrade to version 13.0.1 or newer'
            },
            {
                'package': 'System.Text.RegularExpressions',
                'version_constraint': '<4.3.1',
                'severity': 'high',
                'description': 'Known security vulnerability',
                'recommendation': 'Upgrade to version 4.3.1 or newer'
            }
        ]