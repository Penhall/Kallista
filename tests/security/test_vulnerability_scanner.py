# tests/security/test_vulnerability_scanner.py
import unittest
import asyncio
from unittest.mock import MagicMock, patch
from pathlib import Path
from datetime import datetime

from tools.security.vulnerability_scanner import VulnerabilityScanner

class TestVulnerabilityScanner(unittest.TestCase):
    def setUp(self):
        self.scanner = VulnerabilityScanner()
        self.test_path = Path("test_project")
        self.test_files = {
            'test.cs': '''
                public class TestClass {
                    private string apiKey = "sk_test_123456";
                    public void TestMethod() {
                        var query = "SELECT * FROM Users WHERE id = " + userId;
                    }
                }
            ''',
            'Web.config': '''
                <?xml version="1.0"?>
                <configuration>
                    <connectionStrings>
                        <add name="DefaultConnection" 
                             connectionString="Server=myserver;Database=mydb;User Id=myuser;Password=mypass;" />
                    </connectionStrings>
                    <system.web>
                        <compilation debug="true" />
                    </system.web>
                </configuration>
            ''',
            'packages.config': '''
                <?xml version="1.0"?>
                <packages>
                    <package id="Newtonsoft.Json" version="12.0.1" />
                    <package id="System.Data.SQLite" version="1.0.110" />
                </packages>
            '''
        }

    async def asyncSetUp(self):
        # Setup assíncrono
        self.test_path.mkdir(exist_ok=True)
        for filename, content in self.test_files.items():
            (self.test_path / filename).write_text(content)

    def tearDown(self):
        # Limpa arquivos de teste
        if self.test_path.exists():
            import shutil
            shutil.rmtree(self.test_path)

    def test_init(self):
        """Testa inicialização do scanner"""
        self.assertIsNotNone(self.scanner)
        self.assertIsNotNone(self.scanner.patterns)
        self.assertIn('code_patterns', self.scanner.patterns)
        self.assertIn('config_patterns', self.scanner.patterns)
        self.assertIn('dependency_patterns', self.scanner.patterns)

    async def test_scan_project(self):
        """Testa scan completo do projeto"""
        await self.asyncSetUp()
        
        results = await self.scanner.scan_project(self.test_path)
        
        # Verifica estrutura do resultado
        self.assertIn('code_vulnerabilities', results)
        self.assertIn('config_vulnerabilities', results)
        self.assertIn('dependency_vulnerabilities', results)
        self.assertIn('timestamp', results)
        
        # Verifica se encontrou vulnerabilidades
        self.assertTrue(len(results['code_vulnerabilities']) > 0)
        self.assertTrue(len(results['config_vulnerabilities']) > 0)
        self.assertTrue(len(results['dependency_vulnerabilities']) > 0)

    async def test_scan_code(self):
        """Testa scan de código"""
        await self.asyncSetUp()
        
        vulnerabilities = await self.scanner._scan_code(self.test_path)
        
        # Deve encontrar pelo menos duas vulnerabilidades
        self.assertTrue(len(vulnerabilities) >= 2)
        
        # Verifica vulnerabilidade de API key
        api_key_vuln = next(
            (v for v in vulnerabilities if 'apiKey' in v['snippet']),
            None
        )
        self.assertIsNotNone(api_key_vuln)
        self.assertEqual(api_key_vuln['type'], 'hardcoded_credential')
        
        # Verifica vulnerabilidade de SQL injection
        sql_vuln = next(
            (v for v in vulnerabilities if 'SELECT' in v['snippet']),
            None
        )
        self.assertIsNotNone(sql_vuln)
        self.assertEqual(sql_vuln['type'], 'sql_injection')

    async def test_scan_configs(self):
        """Testa scan de configurações"""
        await self.asyncSetUp()
        
        vulnerabilities = await self.scanner._scan_configs(self.test_path)
        
        # Deve encontrar pelo menos duas vulnerabilidades
        self.assertTrue(len(vulnerabilities) >= 2)
        
        # Verifica vulnerabilidade de connection string
        conn_vuln = next(
            (v for v in vulnerabilities if 'connectionString' in v['snippet']),
            None
        )
        self.assertIsNotNone(conn_vuln)
        self.assertEqual(conn_vuln['severity'], 'high')
        
        # Verifica vulnerabilidade de debug mode
        debug_vuln = next(
            (v for v in vulnerabilities if 'debug="true"' in v['snippet']),
            None
        )
        self.assertIsNotNone(debug_vuln)
        self.assertEqual(debug_vuln['severity'], 'medium')

    async def test_scan_dependencies(self):
        """Testa scan de dependências"""
        await self.asyncSetUp()
        
        vulnerabilities = await self.scanner._scan_dependencies(self.test_path)
        
        # Verifica vulnerabilidades em pacotes
        json_vuln = next(
            (v for v in vulnerabilities 
             if v['package'] == 'Newtonsoft.Json' 
             and v['version'] == '12.0.1'),
            None
        )
        self.assertIsNotNone(json_vuln)
        self.assertEqual(json_vuln['severity'], 'high')

    async def test_find_pattern_matches(self):
        """Testa busca por padrões"""
        await self.asyncSetUp()
        
        pattern = r'password\s*=\s*["\'].*["\']'
        file_types = ['*.config']
        
        matches = await self.scanner._find_pattern_matches(
            self.test_path,
            pattern,
            file_types
        )
        
        self.assertTrue(len(matches) > 0)
        self.assertIn('file', matches[0])
        self.assertIn('line', matches[0])
        self.assertIn('snippet', matches[0])
        self.assertTrue('Password=' in matches[0]['snippet'])

    def test_version_matches(self):
        """Testa comparação de versões"""
        test_cases = [
            ('1.0.0', '>=1.0.0', True),
            ('1.0.0', '>2.0.0', False),
            ('2.0.0', '<=1.0.0', False),
            ('1.0.0', '<2.0.0', True),
            ('1.0.0', '1.0.0', True)
        ]
        
        for version, constraint, expected in test_cases:
            result = self.scanner._version_matches(version, constraint)
            self.assertEqual(
                result,
                expected,
                f"Failed for version={version}, constraint={constraint}"
            )

if __name__ == '__main__':
    unittest.main()